Introduction
* Another dev meeting, another talk about creating a LLVM target?
* Crash course to the LLVM backend.
* Hour-long, packed with gotchas and tips.
* Based on a very small subset of the ARM architecture.

Part 1 - Background

Why a backend talk?
* Complex and vast part of LLVM.
* Confusing at first, but doesn't need to be.
* LLVM can do a lot for you with minimal effort.
* "What I wished I knew when I started".

Why based on ARM?
* It's not X86.
* Simple, RISC-like architecture.
* Use existing tools to test the output.

What you need to start
* Know a little bit about LLVM IR (llvm.org/docs/LangRef.html).
* xdot.py to visualize graphs when debugging (github.com/jrfonseca/xdot.py).
* Check out and build our LLVM repo from GitHub (github.com/frasercrmck/llvm-leg).

Life of a program inside the LLVM backend
* IR -> SelectionDAG -> MachineDAG -> MachineInstr -> MCInst
* Same program, different representations.
* Transforms target-agnostic IR to target-specific instructions/operations.
* Check it out (IR and MI only):
  * llc foo.ll -print-after-all 2>&1 > foo.log

A look at an IR block
* [simple IR listing]
* Typed values.
* Completely target agnostic (modulo intrinsics, data layout).

A look at a SelectionDAG graph
* [picture of a DAG]
* Target-agnostic nodes (ISD namespace).
* Machine nodes (XxxISD namespace) after ISel only.
* Typed values, no register (kind of).
* Different kinds of dependencies (data, order/chain, glue)

A look at a MachineInstr block
* [simple MI listing]
* Untyped, uses register classes.
* Virtual registers (pre-RA) or machine registers (post-RA).
* Operand order: def use imp-def imp-use.

Part 2 - Creating your own backend

Bits of your ISA you need to describe to LLVM
* Instructions.
* Registers and operands.
* Calling conventions.
* Scheduling (not part of this talk).
* ...

Describing registers with Tablegen
* No subregisters?
*
*

Calling convention lowering (1) - TableGen
* Simple calling convention:

  def CC_XXX : CallingConv<[
    // Promote i8/i16 arguments to i32.
    CCIfType<[i8, i16], CCPromoteToType<i32>>,

    // The first 4 arguments are passed in registers
    CCIfType<[i32], CCAssignToReg<[R0, R1, R2, R3]>>,

    // Fall-back, and use the stack.
    CCIfType<[i32], CCAssignToStack<4, 4>>
  ]>;

* Generates functions used in ISelLowering via function pointers.

Calling convention lowering (2) - LowerFormalArguments()
* Assigns locations to arguments, depending on the TableGen-defined calling convention.

  SmallVector<CCValAssign, 16> ArgLocs;
  CCState CCInfo(CallConv, isVarArg, DAG.getMachineFunction(), getTargetMachine(),
                 ArgLocs, *DAG.getContext());
  CCInfo.AnalyzeFormalArguments(Ins, CC_XXX);  // Pointer to TableGen calling convention function.

* Loop over the argument locations, creating DAG nodes for each.
** Registers: Issue CopyFromReg nodes.
** Stack: Create frame indices and stack loads.

Calling convention lowering (3) - LowerReturn()
* Similar to LowerFormalArguments(), but the other way around.
* Define another, 'RetCC_XXX', TableGen calling convention.
* Call 'AnalyzeReturn()' with it.
* Walk the return value locations and issue DAG nodes.
* Usually, return your XXXISD::RET instruction.

Calling convention lowering (4) - LowerCall()
* Similar to both LowerFormalArguments() and LowerReturn().

* Issue a XXXISD::CALLSEQ_START instruction.
* Analyze your outgoing arguments with your TableGen calling convention.
* Build a chained sequence of CopyToRegs and/or stack stores for the argument locations.
* Issue a XXXISD::CALL instruction with this chain.
* Issue a XXXISD::CALLSEQ_END instruction.
* Analyze your incoming return with against your TableGen return calling convention.
* Copy return values out of registers or load them from the stack.

* XXXISD::CALLSEQ_START and XXXISD::CALLSEQ_END are target-specific and
  carry arbitrary information your target might need, such as stack frame sizes.
* They are eliminated by XXXFrameLowering::eliminateCallFramePseudoInstr()

Describing instructions with Tablegen
* Simple DAG pattern (ADDrr)
* Tablegen instruction definition syntax
  * How the operands map with MI (outs, ins, Defs, Uses)
* Tablegen pattern syntax
  * Nodes, operand types/register classes.
  
Immediates
* Operands and Tablegen
* Materializing immediates
* Matching immediate operands (ADDri)

Matching multiple operations
* More complicated DAG patterns
*
*


Frame lowering
* Calculate the stack size.
* emitPrologue: sub sp, sp, #offset
* emitEpilogue: add sp, sp, #offset
* Ommitted: aligning the stack, ...

InstInfo hooks - copyPhysReg
*
*
*

InstInfo hooks - branch-related
* AnalyzeBranch
* RemoveBranch
* InsertBranch

Instruction Printer
* New classes
** XXXAsmPrinter
** XXXInstPrinter
** An MCAsmStreamer (you can usually get away with the defaults)

* TableGen provides the 'AsmString' field, used to print assembly.

== XXXInstrFormats.td ==
  class InstXXX< ..., string asmstr, ... > : Instruction {
    let AsmString = asmstr;
    ...
  }

* Use this field to define the assembly syntax for each instruction in TableGen.

== XXXInstrInfo.td ==
  def ADD : InstXXX<(outs GRRegs:$dst), (ins GRRegs:$src1, GRRegs:$src2),
                    "add $dst, $src1, $src2"> {
  }

* TableGen will call XXXInstPrinter::printOperand() on any operand value it finds.

== XXXInstPrinter.cpp ==
  void XXXInstPrinter::printOperand(const MCInst *MI, unsigned OpNo, raw_ostream &O) {
    const MCOperand &Op = MI->getOperand(OpNo);
    if (Op.isReg()) {
      O << getRegisterName(Op.getReg());   // TableGen generates this function for us from XXXRegisterInfo.td
      return;
    } else if (Op.isImm()) {
      O << Op.getImm();
      return;
    } else if ...
      ...
    }
  }

Code Emitter
* A few new classes
** XXXAsmBackend
** XXXMCCodeEmitter
** XXXObjectWriter
** An MCObjectStreamer (you can usually get away with the defaults)

* TableGen provides the 'Inst' field, used to generate instruction encodings.

== XXXInstrFormats.td ==
  class InstXXX< ... > : Instruction {
    field bits<32> Inst;
    ...
  }

* Use this field to define the binary encodings of each instruction in TableGen.

== XXXInstrInfo.td ==
  def ADD : InstXXX< ... > {
    let Inst{31-28} = 0b1100; // Opcode
  }

* For operand-based encoding, you need to define bit fields with the same name as the operands.

= XXXInstrInfo.td ==
  def ADD : InstXXX<(outs GRRegs:$dst), (ins GRRegs:$src1, GRRegs:$src2), ...> {
    bits<6> src1;
    bits<6> src2;
    bits<6> dst;
    let Inst{31-28} = 0b1100; // Opcode
    let Inst{27-22} = src1;   // First operand
    let Inst{21-16} = src2;   // Second operand
    let Inst{15-10} = dst;    // Destination
  }

* TableGen will then call XXXMCCodeEmitter::getMachineOpValue() on these operands...

== XXXMCCodeEmitter.cpp ==
    unsigned XXXMCCodeEmitter::getMachineOpValue(const MCInst &MI, const MCOperand &MO,
                                                 SmallVectorImpl<MCFixup> &Fixups,
                                                 const MCSubtargetInfo &STI) const {
     if (MO.isReg()) {
       return CTX.getRegisterInfo()->getEncodingValue(MO.getReg());
     } else if (MO.isImm()) {
       return static_cast<unsigned>(MO.getImm());
     } else if ...
       ...
     }
   }

* ... and will place, mask, and shift the returned values into the binary.


Relocations and Fixups
* For values that require fixing up, such as branch targets, we record the relocation
  into Fixups and return zero.

== XXXMCCodeEmitter.cpp ==
    ...
    } else if (MO.isImm()) {
      return static_cast<unsigned>(MO.getImm());
    } else if ...
      ...
    }

    assert(MO.isExpr()); // MO must be an expression by now

    const MCExpr *Expr = MO.getExpr();
    Fixups.push_back(MCFixup::Create(0, Expr, Expr->getFixupKind()));
    return 0;
  }

* You will likely want the Fixup Kind to be target-dependent for more control.

== XXXFixupKinds.h ==
  enum Fixups {
    // Define a target-specific fixup
    fixup_xxx = FirstTargetFixupKind,

    // Marker
    LastTargetFixupKind,
    NumTargetFixupKinds = LastTargetFixupKind - FirstTargetFixupKind
  };

== XXXAsmBackend.cpp ==
  const MCFixupKindInfo& getFixupKindInfo(MCFixupKind Kind) const override {
    const static MCFixupKindInfo Infos[XXX::NumTargetFixupKinds] = {
      // This table must be in the order that the fixup kinds are defined in XXXFixupKinds.h
      // Name        Offset (bits)  Size (bits)  Flags
      { "fixup_xxx", 0,             32,          MCFixupKindInfo::FKF_IsPCRel },
    };
  }

* We must then implement some hooks that are called by LLVM later on,
  after instructions have been emitted and the section layouts have been finalised.
** XXXAsmBackend::processFixupValue()
*** Adjusts the fixup value, e.g., splitting the value up across different bit fields.
** XXXAsmBackend::applyFixup()
*** Patches the fixed-up value into the binary.
** XXXObjectWriter::RecordRelocation()
*** Record the fixup if it could not be resolved and requires external relocation.

Part 3 - 'How to' for specific tasks

Adding a custom SelectionDAG node
* Why
* How
* ...

DAG combining
* Why
* How
* ...

Lowering to multiple instructions (1)
* Example: implement 32-bit immediate load with high/low pairs:
  * MOVW: load 16-bit 'low' immediate and clear high 16 bits.
  * MOVT: load 16-bit 'high' immediate.
* The final value is defined by the second instruction (MOVT).
* Different ways to implement this:
  * At the DAG level, in ISelDAGToDAG.cpp
  * Using a pseudo-instruction.

Lowering to multiple instructions (2)
* Constraint: the two instructions must be ordered.
  * Achieved by having MOVT reading MOVW's output (i.e. fake use).
* Defining instruction in Tablegen: let Constraints = "$src1 = $dst"
  [tablegen def for MOVW/MOVT]
* In DAGs, can use 'Glue' (return type: MVT::Glue).
  [code to select MOVW/MOVT pair with glue]

Lowering to multiple instructions (3)
* Define a pseudo instruction, can be selected using Tablegen patterns.
* Expanded after RA using the InstrInfo::expandPostRAPseudo hook and BuildMI.
  [example code]

Printing custom operands
* E.g. for memory addressing
 [tablegen operand def]
 [tablegen instruction def]
 [c++ printer function]
 [assembly output]

Part 4 - Troubleshooting and tips

When something went wrong
* Find which pass introduces the issue (with llc -print-after-all)
* Find the LLVM source file for this pass and debug category:
  * #define DEBUG_TYPE "codegen-dce"
* Dump the log: llc foo.ll -debug -debug-only codegen-dce 2>&1 > foo.log
* If you have a 'good' build, diff the -print-after-all/-debug-only output.

Debugging LLVM
* MIs, BBs, functions, almost anything -> call X.dump() (to the console)
* DAGs -> call X.viewGraph() (pops up a xdot.py window)
* Or from the terminal: llc foo.ll -view-isel-dags
  * -view-dag1-combine-dags, -view-legalize-dags, -view-sched-dags, etc.
* Make sure you build LLVM in debug mode.
* Turn on LLVM_ENABLE_ASSERTIONS. NDEBUG should not be defined.

Dead code elimination ate my homework
* DCE does not touch MIs with side-effects:
  * mayLoad, mayStore, isTerminator, hasUnmodelledSideEffects
* DCE does not touch MIs whose value is used by other MIs:
  * Root your use/def chains using a MI that has side-effects.

To go further...
* Sub-registers
* Legalization
* Intrinsics
* ...

Q and A
