%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\talksection{Instruction printing}

\begin{frame}{Instruction printer}

\begin{itemize}
    \item New classes:
    \begin{itemize}
        \item LEGAsmPrinter
        \item LEGMCInstLower
        \item An MCAsmStreamer (usually stock)
        \item LEGInstPrinter
    \end{itemize}
    \item LEGAsmPrinter works as a gateway to the streamers
    \item This stages works with MCInsts, lowered from MachineInstrs by LEGMCInstLower
\end{itemize}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}[fragile]{Instruction printer}

\begin{itemize}
    \item TableGen provides the 'AsmString' field:
\end{itemize}

\begin{codebox}
class InstLEG<... , string asmstr> : Instruction {
  let AsmString = asmstr;
  ...
}
\end{codebox}
\codecaption{LEGInstrFormats.t}

\begin{codebox}[commandchars=\\\[\]]
def ADDrr : InstLEG<(outs GRRegs:$dst),
                    (ins GRRegs:$src1, GRRegs:$src2),
                    \codeempha["add $dst, $src1, $src2"]> {
  ...
}
\end{codebox}
\codecaption{LEGInstrInfo.td}

\begin{itemize}
    \item \texttt{LEGInstPrinter::printOperand} will be called on each operand.
\end{itemize}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}[fragile]{Instruction printer}

\begin{itemize}
    \item \texttt{LEGInstPrinter::printOperand} is given the stream to print to.
\end{itemize}

\begin{codebox}
void LEGInstPrinter::printOperand(const MCInst *MI, unsigned No,
                                  raw_ostream &O) {
  const MCOperand &Op = MI->getOperand(No);
  if (Op.isReg()) {
    // TableGen generates this function for us from   
    // LEGRegisterInfo.td
    O << getRegisterName(Op.getReg());
    return;
  }
  if (Op.isImm()) {
    O << '#' << Op.getImm();
    return;
  }
  /* ... */
}
\end{codebox}
\codecaption{LEGInstPrinter.cpp}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}{Instruction printer}

\begin{itemize}
    \item That's it!
    \item Directives and labels handled for us
    \begin{itemize}
        \item Can emit target-specific syntax if we wish
    \end{itemize}
\end{itemize}

\examplebox[firstline=1,lastline=10]{ex1/ex1.s}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\talksection{Instruction encoding}

\begin{frame}{Instruction encoding}

\begin{itemize}
    \item A few new classes:
    \begin{itemize}
        \item An MCObjectStreamer (again, stock)
        \item LEGMCCodeEmitter
        \item LEGObjectWriter
        \item LEGAsmBackend
    \end{itemize}
    \item You will also need your LEGAsmPrinter
\end{itemize}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}[fragile]{Instruction encoding}

Example encoding:

\vspace{1ex}

\begin{tabular}{|c|c|c|c|c|c|c|c|}
\hline 
31...28 & 27...25 & 24...21 & 20 & 19...16 & 15...12 & 11...4 & 3...0\tabularnewline
\hline 
1110 & 000 & opcode & 0 & src1 & dst & 00000000 & src2\tabularnewline
\hline 
\end{tabular}

\vspace{2ex}

How can we achieve this?

\vspace{1ex}

\begin{codebox}[commandchars=\\\{\}]
def ADDrr : InstLEG<(outs GRRegs:$dst),
                    (ins GRRegs:$src1, GRRegs:$src2),
                    "add $dst, $src1, $src2",
                    [(set i32:$dst, (add i32:$src1, i32:$src2))]>;
\end{codebox}
\codecaption[-10.2ex]{LEGInstrInfo.td}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}[fragile]{Instruction encoding}

\begin{itemize}
    \item TableGen recognises the 'Inst' field:
\end{itemize}

\begin{codebox}
class InstLEG< ... > : Instruction {
  field bits<32> Inst;
  ...
}
\end{codebox}
\codecaption{LEGInstrFormats.td}

\begin{itemize}
    \item Used to define the binary encoding of each instruction in TableGen:
\end{itemize}

\begin{codebox}
def ADDrr : InstLEG< ... > {
  let Inst{31-25} = 0b110000;
  let Inst{24-21} = 0b1100;      // Opcode
  let Inst{20}    = 0b0;
  let Inst{11-4}  = 0b00000000;
}
\end{codebox}
\codecaption{LEGInstrInfo.td}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}[fragile]{Instruction encoding}

\begin{itemize}
    \item For operand-based encoding, need bit fields with the same names as the operands:
\end{itemize}

\begin{codebox}[commandchars=\\\[\]]
def ADDrr : InstLEG<(outs GRRegs:\codeemphc[$dst]),
                    (ins GRRegs:\codeempha[$src1], GRRegs:\codeemphb[$src2]) ... > {
  bits<4> \codeempha[src1]; bits<4> \codeemphb[src2]; bits<4> \codeemphc[dst];
  let Inst{31-25} = 0b110000;
  let Inst{24-21} = 0b1100;      // Opcode
  let Inst{20}    = 0b0;
  let Inst{19-16} = \codeempha[src1];        // Operand 1
  let Inst{15-12} = \codeemphc[dst];         // Destination
  let Inst{11-4}  = 0b00000000;
  let Inst{3-0}   = \codeemphb[src2];        // Operand 2
\end{codebox}
\codecaption{LEGInstrInfo.td}

\begin{itemize}
    \item \texttt{LEGMCCodeEmitter::getMachineOpValue()} will be called on each operand
\end{itemize}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}[fragile]{Instruction encoding}

Returns the encoding of each operand...

\begin{codebox}
unsigned LEGMCCodeEmitter::
getMachineOpValue(const MCInst &MI, const MCOperand MO,
                  SmallVectorImpl<MCFixup> &Fixups,
                  const MCSubtargetInfo &STI) const {
  if (MO.isReg()) {
    return
      CTX.getRegisterInfo()->getEncodingValue(MO.getReg());
  } if (MO.isImm()) {
    return static_cast<unsigned>(MO.getImm());
  }
  /* ... */
}
\end{codebox}
\codecaption{LEGMCCodeEmitter.cpp}

...placed, masked, and shifted into position

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}[fragile]{Relocations and fixups}

\begin{itemize}
    \item For values that require fixing up, record the relocation into Fixups and return zero.
\end{itemize}

\begin{codebox}
unsigned LEGMCCodeEmitter::
getMachineOpValue(const MCInst &MI, const MCOperand MO,
                  SmallVectorImpl<MCFixup> &Fixups,
                  const MCSubtargetInfo &STI) const {
  /* ... */

  assert(MO.isExpr()); // MO must be an expression
  
  const MCExpr *Expr = MO.getExpr();
  const MCExpr::ExprKind Kind = Expr->getFixupKind();

  Fixups.push_back(MCFixup::Create(0, Expr, Kind));
  return 0;
}
\end{codebox}
\codecaption{LEGMCCodeEmitter.cpp}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}[fragile]{Relocations and fixups}

\begin{itemize}
    \item Defining a target-specific fixup:
\end{itemize}

\begin{codebox}
enum Fixups {
  fixup_leg_movt_hi16_pcrel = FirstTargetFixupKind,
  fixup_leg_movw_lo16_pcrel,
  
  LastTargetFixupKind,
  NumTargetFixupKinds = LastTargetFixupKind - FirstTargetFixupKind
};
\end{codebox}
\codecaption{LEGFixups.h}

\begin{codebox}
const MCFixupKindInfo& getFixupKindInfo(MCFixupKind K) const {
  const static MCFixupKindInfo I[LEG::NumTargetFixupKinds] = {
    // Name          Offset Size Flags
    { "fixup_leg_movt_hi16_pcrel", 0,  32, MCFixupKindInfo::FKF_IsPCRel },
    { "fixup_leg_movw_lo16_pcrel", 0,  32, MCFixupKindInfo::FKF_IsPCRel },
  };
  /* ... */
  return I[K - FirstTargetFixupKind];
}
\end{codebox}
\codecaption{LEGAsmBackend.cpp}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}{Relocations and fixups}

\begin{itemize}
    \item We must then implement some hooks
    \item These are called at the end once the section layouts have been finalized
    \item \texttt{LEGAsmBackend::processFixupValue()}
    \begin{itemize}
        \item Adjusts the fixup value, e.g., splitting the value across non-contiguous fields
    \end{itemize}
    \item \texttt{LEGAsmBackend::applyFixup()}
    \begin{itemize}
        \item Patches the fixed-up value into the binary stream
    \end{itemize}
\end{itemize}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\talksection{Selection DAG manipulation}

\begin{frame}[fragile]{Custom SelectionDAG nodes}

\begin{itemize}
    \item To represent target-specific operations in the DAG
    \begin{itemize}
        \item Example: 32-bit immediate move on ARM
    \end{itemize}
    \item How?
    \begin{itemize}
        \item Add a value in the \texttt{LEGISD} enum
        \item Update \texttt{LEGTargetLowering::getTargetNodeName()}
        \item Add TableGen node definitions
        \begin{itemize}
            \item Type definition: number of inputs, outputs, constraints
            \item Node definition: tablegen name, opcode, type
        \end{itemize}
    \end{itemize}
    \item Custom nodes can be used in TableGen selection patterns
\end{itemize}

\begin{codebox}
def MoveImm32Ty : SDTypeProfile<1, 1, [
  SDTCisSameAs<0, 1>, SDTCisInt<0>
]>;

def movei32 : SDNode<"LEGISD::MOVi32", MoveImm32Ty>;
\end{codebox}
\codecaption{LEGOperators.td}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}[fragile]{Custom DAG lowering}

\begin{itemize}
    \item To handle DAG nodes in a special way
    \begin{itemize}
        \item Replaces an existing node with one or more other DAG nodes
        \item Matches nodes by opcode (e.g. \texttt{ISD::Constant})
        \item Matches nodes by type (e.g. \texttt{i32})
    \end{itemize}
    \item How?
    \begin{itemize}
        \item Call \texttt{setOperationAction(\emph{nodeOpcode}, type, Custom)}
        \item Create a function to handle it (e.g. \texttt{LowerOPCODE})
        \item Add a 'switch' case in \texttt{LowerOperation} that calls \texttt{LowerOPCODE}
    \end{itemize}
    \item This all hapens in \texttt{LEGTargetLowering} (\texttt{LEGISelLowering.cpp})
\end{itemize}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}[fragile]{Custom DAG lowering: \texttt{LowerOPCODE}}

\begin{itemize}
    \item \texttt{LowerOPCODE} takes a DAG node (\texttt{Op}) and returns a DAG node
    \item You can:
    \begin{itemize}
        \item Return a different node
        \item Return \texttt{Op} → no change
        \item Return \texttt{SDValue()} → node not supported (LLVM will expand it)
    \end{itemize}
    \item All of the above can be done conditionally (e.g. depending on \texttt{VT})
\end{itemize}

\begin{codebox}
SDValue LEGTargetLowering::LowerConstant(SDValue Op,
                                         SelectionDAG &DAG) const {
  EVT VT = Op.getValueType();
  ConstantSDNode *Val = cast<ConstantSDNode>(Op.getNode());
  SDValue TargetVal = DAG.getTargetConstant(Val->getZExtVaue(),
                                            MVT::i32);
  return DAG.getNode(LEGISD::MOVi32, VT, TargetVal);
}
\end{codebox}
\codecaption{LEGISelLowering.cpp}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}[fragile]{Creating SelectionDAG nodes}

\begin{itemize}
    \item Simply call \texttt{DAG.getNode()} with these arguments:
    \begin{itemize}
        \item Node opcode (e.g. \texttt{LEGISD::MOVi32}), type, operand(s)
    \end{itemize}
    \item Nodes are target-independent (\texttt{ISD}) or not (\texttt{LEGISD})
    \item Use \texttt{DAG.getMachineNode()} in LEGISelDAGToDAG
\end{itemize}

\begin{codebox}
SDValue LEGTargetLowering::LowerConstant(SDValue Op,
                                         SelectionDAG &DAG) const {
  EVT VT = Op.getValueType();
  ConstantSDNode *Val = cast<ConstantSDNode>(Op.getNode());
  SDValue TargetVal = DAG.getTargetConstant(Val->getZExtVaue(),
                                            MVT::i32);
  return DAG.getNode(LEGISD::MOVi32, VT, TargetVal);
}
\end{codebox}
\codecaption{LEGISelLowering.cpp}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}{Lowering to multiple instructions}

\begin{itemize}
    \item Example: implement 32-bit immediate load with high/low pairs:
    \begin{itemize}
        \item MOVW: load 16-bit 'low' immediate and clear high 16 bits
        \item MOVT: load 16-bit 'high' immediate
    \end{itemize}
    \item The final value is defined by the second instruction
    \item Different ways to implement this:
    \begin{itemize}
        \item At the DAG level, in LEGISelDAGToDAG.cpp
        \item Using a pseudo-instruction (placeholder)
    \end{itemize}
\end{itemize}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}{Lowering to multiple instructions}

\begin{columns}[t]
\column{.5\textwidth}
    \begin{itemize}
        \item The two instructions must be ordered
        \begin{itemize}
            \item MOVW clears the high 16 bits
            \item MOVT followed by MOVW gives the wrong result
        \end{itemize}
        \item Achieved by having MOVT reading MOVW's output
        \begin{itemize}
            \item Add a 'fake' operand to MOVT
            \item Enforces the ordering
        \end{itemize}
        \item Example: \texttt{0x00010002}
    \end{itemize}
\column{.5\textwidth}
    \begin{figure}
        \vspace{-5ex}
        \includegraphics[width = 0.78\textwidth]{examples/ex5/ex5-post-isel.pdf}
    \end{figure}
\end{columns}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}[fragile]{Lowering to multiple instructions}

\begin{itemize}
    \item Let's define MOVT with the extra operand: fakesrc
    \item Source and destination registers must be the same
    \begin{itemize}
        \item Use 'Constraints' in Tablegen
    \end{itemize}
\end{itemize}

\begin{codebox}[commandchars=\\¬|]
def MOVTi16 : InstLEG<(outs GRRegs:$dst),
                      (ins GRRegs:\codeempha¬$fakesrc|, i32imm:$src),
                      "movw $dst, $src",
                      [/* No pattern */]> {
  let Constraints = "$src1 = $dst";
}
\end{codebox}
\codecaption{LEGInstrInfo.td}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}[fragile]{Lowering to multiple instructions}

\begin{itemize}
    \item Define a pseudo instruction, can be selected from the custom DAG node we previously defined
    \item The pseudo is lowered by a target hook
\end{itemize}

\begin{codebox}
def MOVi32 : InstLEG<(outs GRRegs:$dst), (ins i32imm:$src), "",
                     [(set i32:$dst, (movei32 i32imm:$src))]> {
  let isPseudo = 1;
}
\end{codebox}
\codecaption{LEGInstrInfo.td}

% FIXME split into two slides: pseudo and lowering
\begin{codebox}
bool LEGInstrInfo::expandPostRAPseudo(MachineInstr *MI) {
   if (MI->getOpcode() != LEG::MOVi32) return false;
   BuildMI(..., get(LEG::MOVWi16), Dst).addImm(Lo);
   BuildMI(..., get(LEG::MOVTi16), Dst).addReg(Dst).addImm(Hi);
   MBB.erase(MI);
   return true;
}
\end{codebox}
\codecaption{LEGInstrInfo.cpp}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}{Lowering to multiple instructions}

\begin{columns}[t]
\column{.5\textwidth}
    Example IR:
    \examplebox[firstline=6,lastline=9]{ex5/ex5.ll}

    Result assembly:
    \examplebox[firstline=7,lastline=11,gobble=1]{ex5/ex5.s}
\column{.5\textwidth}
    \begin{figure}
        \vspace{-5ex}
        \includegraphics[width = 0.78\textwidth]{examples/ex5/ex5-post-isel.pdf}
    \end{figure}
\end{columns}

\end{frame}
