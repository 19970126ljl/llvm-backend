%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Instruction encoding}

\begin{frame}{Instruction encoding}

\begin{itemize}
    \item A few new classes:
    \begin{itemize}
        \item LEGAsmBackend
        \item LEGMCCodeEmitter
        \item LEGObjectWriter
        \item An MCObjectStreamer (again, stock)
    \end{itemize}
    \item You will also need your LEGAsmPrinter
\end{itemize}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}[fragile]{Instruction encoding}

Example encoding:

\vspace{1ex}

\begin{tabular}{|c|c|c|c|c|c|c|c|}
\hline 
31...28 & 27...25 & 24...21 & 20 & 19...16 & 15...12 & 11...4 & 3...0\tabularnewline
\hline 
1110 & 000 & opcode & 0 & src1 & dst & 00000000 & src2\tabularnewline
\hline 
\end{tabular}

\vspace{2ex}

How can we achieve this?

\vspace{1ex}

\begin{codebox}[commandchars=\\\{\}]
def ADDrr : InstLEG<(outs GRRegs:$dst),
                    (ins GRRegs:$src1, GRRegs:$src2),
                    "add $dst, $src1, $src2",
                    [(set i32:$dst, (add i32:$src1, i32:$src2))]>;
\end{codebox}
\codecaption[-10.2ex]{LEGInstrInfo.td}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}[fragile]{Instruction encoding}

\begin{itemize}
    \item TableGen recognises the 'Inst' field:
\end{itemize}

\begin{codebox}
class InstLEG< ... > : Instruction {
  field bits<32> Inst;
  ...
}
\end{codebox}
\codecaption{LEGInstrFormats.td}

\begin{itemize}
    \item Used to define the binary encoding of each instruction in TableGen:
\end{itemize}

\begin{codebox}
def ADDrr : InstLEG< ... > {
  let Inst{31-25} = 0b110000;
  let Inst{24-21} = 0b1100;      // Opcode
  let Inst{20}    = 0b0;
  let Inst{11-4}  = 0b00000000;
}
\end{codebox}
\codecaption{LEGInstrInfo.td}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}[fragile]{Instruction encoding}

\begin{itemize}
    \item For operand-based encoding, need bit fields with the same names as the operands:
\end{itemize}

\begin{codebox}[commandchars=\\\[\]]
def ADDrr : InstLEG<(outs GRRegs:\codeemphc[$dst]),
                    (ins GRRegs:\codeempha[$src1], GRRegs:\codeemphb[$src2]) ... > {
  bits<4> \codeempha[src1]; bits<4> \codeemphb[src2]; bits<4> \codeemphc[dst];
  let Inst{31-25} = 0b110000;
  let Inst{24-21} = 0b1100;      // Opcode
  let Inst{20}    = 0b0;
  let Inst{19-16} = \codeempha[src1];        // Operand 1
  let Inst{15-12} = \codeemphc[dst];         // Destination
  let Inst{11-4}  = 0b00000000;
  let Inst{3-0}   = \codeemphb[src2];        // Operand 2
\end{codebox}
\codecaption{LEGInstrInfo.td}

\begin{itemize}
    \item \texttt{LEGMCCodeEmitter::getMachineOpValue()} will be called on each operand
\end{itemize}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}[fragile]{Instruction encoding}

Returns the encoding of each operand...

\begin{codebox}
unsigned LEGMCCodeEmitter::
getMachineOpValue(const MCInst &MI, const MCOperand MO,
                  SmallVectorImpl<MCFixup> &Fixups,
                  const MCSubtargetInfo &STI) const {
  if (MO.isReg()) {
    return
      CTX.getRegisterInfo()->getEncodingValue(MO.getReg());
  } if (MO.isImm()) {
    return static_cast<unsigned>(MO.getImm());
  }
  /* ... */
}
\end{codebox}
\codecaption{LEGMCCodeEmitter.cpp}

...placed, masked, and shifted into position

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}[fragile]{Relocations and fixups}

\begin{itemize}
    \item For values that require fixing up, record the relocation into Fixups and return zero.
\end{itemize}

\begin{codebox}
unsigned LEGMCCodeEmitter::
getMachineOpValue(const MCInst &MI, const MCOperand MO,
                  SmallVectorImpl<MCFixup> &Fixups,
                  const MCSubtargetInfo &STI) const {
  /* ... */

  assert(MO.isExpr()); // MO must be an expression
  
  const MCExpr *Expr = MO.getExpr();
  const MCExpr::ExprKind Kind = Expr->getFixupKind();

  Fixups.push_back(MCFixup::Create(0, Expr, Kind));
  return 0;
}
\end{codebox}
\codecaption{LEGMCCodeEmitter.cpp}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}[fragile]{Relocations and fixups}

\begin{itemize}
    \item Defining a target-specific fixup:
\end{itemize}

\begin{codebox}
enum Fixups {
  fixup_leg_pcrel = FirstTargetFixupKind,
  
  LastTargetFixupKind,
  NumTargetFixupKinds = LastTargetFixupKind - FirstTargetFixupKind
};
\end{codebox}
\codecaption{LEGFixups.h}

\begin{codebox}
const MCFixupKindInfo& getFixupKindInfo(MCFixupKind K) const {
  const static MCFixupKindInfo I[LEG::NumTargetFixupKinds] = {
    // Name          Offset Size Flags
    { "fixup_leg_pcrel", 0,  32, MCFixupKindInfo::FKF_IsPCRel },
  };
  /* ... */
  return I[K - FirstTargetFixupKind];
}
\end{codebox}
\codecaption{LEGAsmBackend.cpp}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}{Relocations and fixups}

\begin{itemize}
    \item We must then implement some hooks
    \item These are called at the end once the section layouts have been finalized
    \item \texttt{LEGAsmBackend::processFixupValue()}
    \begin{itemize}
        \item Adjusts the fixup value, e.g., splitting the value across non-contiguous fields
    \end{itemize}
    \item \texttt{LEGAsmBackend::applyFixup()}
    \begin{itemize}
        \item Patches the fixed-up value into the binary stream
    \end{itemize}
\end{itemize}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}[fragile]{Custom SelectionDAG nodes}

\begin{itemize}
    \item To represent target-specific operations in the DAG
    \begin{itemize}
        \item Example: 32-bit immediate move on ARM
    \end{itemize}
    \item Add a value in the \texttt{LEGISD} enum
    \item Add to \texttt{LEGTargetLowering::getTargetNodeName()}
    \item Add TableGen node definition:
\end{itemize}

\begin{codebox}
def MoveImm32Ty : SDTypeProfile<1, 1, [
  SDTCisSameAs<0, 1>, SDTCisInt<0>
]>;

def movei32 : SDNode<"LEGISD::MOVi32", MoveImm32Ty>;
\end{codebox}
\codecaption{LEGOperators.td}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}[fragile]{Custom DAG lowering}

\begin{itemize}
    \item To implement an operation in a more efficient way
    \begin{itemize}
        \item E.g. by replacing it with a custom DAG node
    \end{itemize}
    \item To work around target limitations
    \begin{itemize}
        \item E.g. by replacing it with multiple DAG nodes
    \end{itemize}
    \item Add support to \texttt{LEGISelLowering::LowerOperation}
    \item Set the operation action to 'custom' on given type:
\end{itemize}

\begin{codebox}
LEGISelLowering::LEGISelLowering(/* ... */) {
  /* ... */
  setOperationAction(ISD::GlobalAddress, MVT::i32, Custom);
}
\end{codebox}
\codecaption{LEGISelLowering.cpp}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}[fragile]{Creating SelectionDAG nodes}

\begin{itemize}
    \item Simply call \texttt{DAG.getNode()} with these arguments:
    \begin{itemize}
        \item Node ID (e.g. \texttt{LEGISD::MOVi32}), type, operand(s)
    \end{itemize}
    \item Nodes are target-independent (\texttt{ISD}) or not (\texttt{LEGISD})
    \item Use \texttt{DAG.getMachineNode()} in LEGISelDAGToDAG
\end{itemize}

\begin{codebox}
SDValue LEGTargetLowering::LowerConstant(SDValue Op,
                                         SelectionDAG &DAG) const {
  EVT VT = Op.getValueType();
  ConstantSDNode *Val = cast<ConstantSDNode>(Op.getNode());
  SDValue TargetVal = DAG.getTargetConstant(Val->getZExtVaue(),
                                            MVT::i32);
  return DAG.getNode(LEGISD::MOVi32, VT, TargetVal);
}
\end{codebox}
\codecaption{LEGISelLowering.cpp}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}{Lowering to multiple instructions}

\begin{itemize}
    \item Example: implement 32-bit immediate load with high/low pairs:
    \begin{itemize}
        \item MOVW: load 16-bit 'low' immediate and clear high 16 bits
        \item MOVT: load 16-bit 'high' immediate
    \end{itemize}
    \item The final value is defined by the second instruction
    \item Different ways to implement this:
    \begin{itemize}
        \item At the DAG level, in LEGISelDAGToDAG.cpp
        \item Using a pseudo-instruction (placeholder)
    \end{itemize}
\end{itemize}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}[fragile]{Lowering to multiple instructions}

\begin{itemize}
    \item The two instructions must be ordered:
    \begin{itemize}
        \item Because MOVW clears the high 16 bits
        \item Achieved by having MOVT reading MOVW's output
    \end{itemize}
    \item Source and destination registers must be the same
    \begin{itemize}
        \item Use 'Constraints' in Tablegen (unless using pseudo)
    \end{itemize}
\end{itemize}

\begin{codebox}
def MOVTi16 : InstLEG<(outs GRRegs:$dst),
                      (ins GRRegs:$src1, i32imm:$src2),
                      "movw $dst, $src2",
                      [/* No pattern */]> {
  let Constraints = "$src1 = $dst";
}
\end{codebox}
\codecaption{LEGInstrInfo.td}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}[fragile]{Lowering to multiple instructions}

\begin{itemize}
    \item Define a pseudo instruction, can be selected from the custom DAG node we previously defined
    \item The pseudo is lowered by a target hook
\end{itemize}

\begin{codebox}
def MOVi32 : InstLEG<(outs GRRegs:$dst), (ins i32imm:$src), "",
                     [(set i32:$dst, (movei32 i32imm:$src))]> {
  let isPseudo = 1;
}
\end{codebox}
\codecaption{LEGInstrInfo.td}

% FIXME split into two slides: pseudo and lowering
\begin{codebox}
bool LEGInstrInfo::expandPostRAPseudo(MachineInstr *MI) {
   if (MI->getOpcode() != LEG::MOVi32) return false;
   BuildMI(..., get(LEG::MOVWi16), Dst).addImm(Lo);
   BuildMI(..., get(LEG::MOVTi16), Dst).addReg(Dst).addImm(Hi);
   MBB.erase(MI);
   return true;
}
\end{codebox}
\codecaption{LEGInstrInfo.cpp}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}{Lowering to multiple instructions}

Example IR:

\examplebox[firstline=6,lastline=9]{ex5/ex5.ll}

Outputs:

\examplebox[firstline=7,lastline=12,gobble=1]{ex5/ex5.s}

\end{frame}
